<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CENG 351 Lab 1: Hierarchy, Regularity, Modularity</title>
    <style>
        body {
            font-family: 'Times New Roman', serif;
            line-height: 1.6;
            margin: 0;
            padding: 40px;
            background-color: white;
            color: #333;
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            border-bottom: 3px solid #2c3e50;
            padding-bottom: 20px;
        }
        
        .title {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 18px;
            color: #7f8c8d;
            margin-bottom: 5px;
        }
        
        .course-info {
            font-size: 14px;
            color: #95a5a6;
        }
        
        .section {
            margin-bottom: 30px;
            page-break-inside: avoid;
        }
        
        .section-title {
            font-size: 18px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 15px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }
        
        .subsection-title {
            font-size: 16px;
            font-weight: bold;
            color: #34495e;
            margin-bottom: 10px;
            margin-top: 20px;
        }
        
        .screenshot-container {
            text-align: center;
            margin: 20px 0;
            page-break-inside: avoid;
        }
        
        .screenshot {
            max-width: 100%;
            height: auto;
            border: 2px solid #bdc3c7;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .screenshot-caption {
            font-size: 12px;
            color: #7f8c8d;
            margin-top: 8px;
            font-style: italic;
        }
        
        .question {
            background-color: #ecf0f1;
            padding: 15px;
            border-left: 4px solid #e74c3c;
            margin: 15px 0;
        }
        
        .question-text {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .answer {
            background-color: #f8f9fa;
            padding: 15px;
            border-left: 4px solid #27ae60;
            margin: 10px 0;
        }
        
        .circuit-description {
            background-color: #fff3cd;
            padding: 15px;
            border: 1px solid #ffeaa7;
            border-radius: 5px;
            margin: 15px 0;
        }
        
        .truth-table {
            margin: 20px 0;
            border-collapse: collapse;
            width: 100%;
        }
        
        .truth-table th,
        .truth-table td {
            border: 1px solid #bdc3c7;
            padding: 8px;
            text-align: center;
        }
        
        .truth-table th {
            background-color: #34495e;
            color: white;
            font-weight: bold;
        }
        
        .truth-table tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        
        .conclusion {
            background-color: #e8f5e8;
            padding: 20px;
            border: 1px solid #27ae60;
            border-radius: 5px;
            margin-top: 30px;
        }
        
        .team-info {
            background-color: #f0f8ff;
            padding: 15px;
            border: 1px solid #3498db;
            border-radius: 5px;
            margin-bottom: 30px;
        }
        
        @media print {
            body { margin: 20px; }
            .section { page-break-inside: avoid; }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="title">CENG 351: Computer Architecture I</div>
        <div class="subtitle">Lab 1: Hierarchy, Regularity, Modularity</div>
        <div class="course-info">4-Bit Full Adder Implementation and Analysis</div>
    </div>

    <div class="team-info">
        <div class="subsection-title">Team Information</div>
        <p><strong>Lab Partners:</strong> Gabriel Giancarlo, Jun Yi</p>
        <p><strong>Contributions:</strong></p>
        <ul>
            <li><strong>Jun Yi:</strong> Circuit design and implementation of both the 1-bit and 4-bit full adders, simulation execution, and screenshot capture</li>
            <li><strong>Gabriel Giancarlo:</strong> Circuit verification in Logisim-evolution, comprehensive report writing, technical analysis, and answering all lab questions</li>
        </ul>
    </div>

    <div class="section">
        <div class="section-title">1. Introduction</div>
        <p>In this lab, we implemented a hierarchical 4-bit full adder to demonstrate the fundamental principles of digital circuit design. Our design showcases three key architectural principles:</p>
        <ul>
            <li><strong>Hierarchy:</strong> We built complex circuits from simpler, reusable components</li>
            <li><strong>Regularity:</strong> We used identical building blocks in a systematic pattern</li>
            <li><strong>Modularity:</strong> We created self-contained, well-defined circuit modules</li>
        </ul>
        
        <div class="circuit-description">
            <div class="subsection-title">Circuit Overview</div>
            <p>We constructed the 4-bit full adder using four identical 1-bit full adder modules connected in a ripple-carry configuration. Each 1-bit adder implements the following logic:</p>
            <ul>
                <li><strong>Sum (S):</strong> S = A ⊕ B ⊕ C<sub>in</sub></li>
                <li><strong>Carry Out (C<sub>out</sub>):</strong> C<sub>out</sub> = (A·B) + (A·C<sub>in</sub>) + (B·C<sub>in</sub>)</li>
            </ul>
        </div>
    </div>

    <div class="section">
        <div class="section-title">2. Circuit Design and Implementation</div>
        
        <div class="subsection-title">2.1 One-Bit Full Adder</div>
        <p>We designed the fundamental building block as a 1-bit full adder that takes three inputs (A, B, C<sub>in</sub>) and produces two outputs (Sum, C<sub>out</sub>). Our implementation uses:</p>
        <ul>
            <li>Two XOR gates for sum calculation</li>
            <li>Three AND gates for carry generation</li>
            <li>One 3-input OR gate for carry propagation</li>
        </ul>

        <div class="subsection-title">2.2 Four-Bit Full Adder Architecture</div>
        <p>We cascaded four 1-bit adders with the carry-out of each stage feeding into the carry-in of the next stage. This creates a ripple-carry adder that can handle 4-bit binary addition with proper carry propagation.</p>

        <div class="screenshot-container">
            <img src="Files to Turn In/Lab 1/ScreenShots/step 1.jpg" alt="Initial Circuit Setup" class="screenshot">
            <div class="screenshot-caption">Figure 1: Initial circuit setup showing the 4-bit full adder with input pins A, B, and C_in</div>
        </div>
    </div>

    <div class="section">
        <div class="section-title">3. Simulation and Testing</div>
        
        <div class="subsection-title">3.1 Test Case: A = 7, B = 1</div>
        <p>We performed the simulation with the specified test values:</p>
        <ul>
            <li><strong>A = 7</strong> (binary: 0111)</li>
            <li><strong>B = 1</strong> (binary: 0001)</li>
            <li><strong>C_in = 0</strong></li>
        </ul>

        <div class="screenshot-container">
            <img src="Files to Turn In/Lab 1/ScreenShots/step 2.jpg" alt="Setting Input A = 7" class="screenshot">
            <div class="screenshot-caption">Figure 2: Setting input A to 7 (binary: 0111)</div>
        </div>

        <div class="screenshot-container">
            <img src="Files to Turn In/Lab 1/ScreenShots/step 3.jpg" alt="Setting Input B = 1" class="screenshot">
            <div class="screenshot-caption">Figure 3: Setting input B to 1 (binary: 0001)</div>
        </div>

        <div class="subsection-title">3.2 Step-by-Step Simulation</div>
        <p>The following screenshots demonstrate the ripple-carry propagation through our circuit:</p>

        <div class="screenshot-container">
            <img src="Files to Turn In/Lab 1/ScreenShots/step 4.jpg" alt="Simulation Step 4" class="screenshot">
            <div class="screenshot-caption">Figure 4: Early simulation step showing signal propagation</div>
        </div>

        <div class="screenshot-container">
            <img src="Files to Turn In/Lab 1/ScreenShots/step 5.jpg" alt="Simulation Step 5" class="screenshot">
            <div class="screenshot-caption">Figure 5: Intermediate simulation step</div>
        </div>

        <div class="screenshot-container">
            <img src="Files to Turn In/Lab 1/ScreenShots/step 10.jpg" alt="Simulation Step 10" class="screenshot">
            <div class="screenshot-caption">Figure 6: Mid-simulation showing carry propagation</div>
        </div>

        <div class="screenshot-container">
            <img src="Files to Turn In/Lab 1/ScreenShots/step 15.jpg" alt="Simulation Step 15" class="screenshot">
            <div class="screenshot-caption">Figure 7: Near completion of simulation</div>
        </div>

        <div class="screenshot-container">
            <img src="Files to Turn In/Lab 1/ScreenShots/step 18_Final_step.jpg" alt="Final Result" class="screenshot">
            <div class="screenshot-caption">Figure 8: Final result showing Sum = 8 (binary: 1000) and C_out = 0</div>
        </div>

        <div class="subsection-title">3.3 Expected vs. Actual Results</div>
        <table class="truth-table">
            <tr>
                <th>Input A</th>
                <th>Input B</th>
                <th>C_in</th>
                <th>Expected Sum</th>
                <th>Actual Sum</th>
                <th>Expected C_out</th>
                <th>Actual C_out</th>
                <th>Result</th>
            </tr>
            <tr>
                <td>7 (0111)</td>
                <td>1 (0001)</td>
                <td>0</td>
                <td>8 (1000)</td>
                <td>8 (1000)</td>
                <td>0</td>
                <td>0</td>
                <td>✓ Correct</td>
            </tr>
        </table>
    </div>

    <div class="section">
        <div class="section-title">4. Lab Questions and Analysis</div>

        <div class="question">
            <div class="question-text">Question 1: Why do you think you were asked to use the input values 7 and 1 for your simulation?</div>
        </div>
        <div class="answer">
            <p>We believe the input values A = 7 and B = 1 were specifically chosen to demonstrate several important aspects of the 4-bit full adder:</p>
            <ul>
                <li><strong>Carry Propagation:</strong> The addition 7 + 1 = 8 requires a carry to propagate from the least significant bit (LSB) through multiple stages, demonstrating the ripple-carry mechanism.</li>
                <li><strong>Binary Representation:</strong> 7 (0111) + 1 (0001) = 8 (1000) shows a clear transition in binary representation that's easy to verify.</li>
                <li><strong>No Overflow:</strong> The result (8) fits within 4 bits, so C_out = 0, demonstrating proper handling of non-overflow cases.</li>
                <li><strong>Step-by-Step Visualization:</strong> The carry propagation from LSB to MSB provides clear visual feedback during simulation.</li>
                <li><strong>Educational Value:</strong> This test case is simple enough to understand but complex enough to show the full functionality of the circuit.</li>
            </ul>
        </div>

        <div class="question">
            <div class="question-text">Question 2: How would the operation of the multibit adder change if you used 4 and 2 as input values?</div>
        </div>
        <div class="answer">
            <p>If we used A = 4 and B = 2, we would observe the following:</p>
            <ul>
                <li><strong>Input Values:</strong> A = 4 (binary: 0100), B = 2 (binary: 0010)</li>
                <li><strong>Expected Result:</strong> 4 + 2 = 6 (binary: 0110)</li>
                <li><strong>Carry Behavior:</strong> No carry propagation would occur since there are no consecutive 1s in the same bit positions.</li>
                <li><strong>Simulation Differences:</strong>
                    <ul>
                        <li>Fewer simulation steps would be required</li>
                        <li>No ripple-carry effect would be visible</li>
                        <li>The result would be computed more quickly</li>
                        <li>Less dramatic visual demonstration of the carry mechanism</li>
                    </ul>
                </li>
                <li><strong>Educational Impact:</strong> This test case would be less effective for demonstrating the ripple-carry adder's key feature of carry propagation, making it a less comprehensive test of the circuit's functionality.</li>
            </ul>
        </div>

        <div class="question">
            <div class="question-text">Question 3: How would the operation of the multibit adder change if you did not reset the simulation before changing the inputs?</div>
        </div>
        <div class="answer">
            <p>If we did not reset the simulation before changing inputs, we would encounter several issues:</p>
            <ul>
                <li><strong>State Persistence:</strong> The circuit would retain the previous simulation state, including any intermediate carry values and signal propagation states.</li>
                <li><strong>Incorrect Results:</strong> The new inputs (A = 4, B = 2) would be processed with residual carry signals from the previous calculation (7 + 1), leading to incorrect results.</li>
                <li><strong>Timing Issues:</strong> The simulation would not start from a clean state, potentially causing timing violations or race conditions.</li>
                <li><strong>Debugging Difficulties:</strong> It would be impossible to verify the correctness of the new calculation since the circuit state would be contaminated.</li>
                <li><strong>Educational Confusion:</strong> We would not be able to clearly observe the step-by-step operation of the circuit for the new inputs.</li>
            </ul>
            <p><strong>Best Practice:</strong> We always reset the simulation (Cmd+R or Ctrl+R) before changing inputs to ensure a clean starting state and accurate results.</p>
        </div>
    </div>

    <div class="section">
        <div class="section-title">5. Troubleshooting and Challenges</div>
        <p>During our implementation and testing of this lab, we encountered several challenges and resolved them:</p>
        <ul>
            <li><strong>Initial Wiring Issues:</strong> Our first attempt at the 1-bit adder had incorrect gate connections, which we resolved by carefully following the truth table and logic equations.</li>
            <li><strong>Carry Propagation:</strong> Ensuring proper carry-out to carry-in connections between the 1-bit adder stages required careful attention to pin assignments.</li>
            <li><strong>Input/Output Configuration:</strong> Setting the correct radix (binary) for the input pins was crucial for proper simulation and result interpretation.</li>
            <li><strong>Simulation Timing:</strong> Understanding when to pause, reset, and step through the simulation required practice with the Logisim-evolution interface.</li>
        </ul>
    </div>

    <div class="section">
        <div class="section-title">6. Conclusion</div>
        <div class="conclusion">
            <p>This lab successfully demonstrated the implementation of a hierarchical 4-bit full adder using the principles of hierarchy, regularity, and modularity. Key achievements include:</p>
            <ul>
                <li>✓ Correct implementation of a 1-bit full adder using basic logic gates</li>
                <li>✓ Successful cascading of four 1-bit adders to create a 4-bit ripple-carry adder</li>
                <li>✓ Proper simulation and verification of the circuit with test case A = 7, B = 1</li>
                <li>✓ Understanding of carry propagation and ripple-carry adder operation</li>
                <li>✓ Demonstration of hierarchical design principles in digital circuit implementation</li>
            </ul>
            <p>The circuit correctly computes 7 + 1 = 8, demonstrating proper binary arithmetic and carry handling. The step-by-step simulation clearly shows the ripple-carry mechanism in action, providing valuable insight into the operation of multibit adders.</p>
        </div>
    </div>

    <div class="section">
        <div class="section-title">7. References</div>
        <ul>
            <li>Logisim-evolution Documentation: https://github.com/logisim-evolution/logisim-evolution</li>
            <li>Digital Design and Computer Architecture, Harris & Harris</li>
            <li>CENG 351 Course Materials: Computer Architecture I</li>
        </ul>
    </div>
</body>
</html>
